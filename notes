Важные функции:
1. fork - создает дочерний процесс. Создается копия нашего кода со всей памятью и переменными.
https://www.opennet.ru/man.shtml?topic=fork&category=2 - fork
https://www.opennet.ru/docs/RUS/linux_parallel/node7.html
У них нет общей области видимости. Что вы измените в дочернем процессе, то не изменится в родительском.
pid - это id процесса, proces id.
При вызове fork в родительском провессе вернется pid дочернего процесса.
А в дочернем процессе вернется pid равный 0;
2. wait - нужен на случай, когда родительский процесс должен подождать дочерний.
Есть 2 варианта - wait и waitpid.
pid_t wait(int *status); - status нужен для того, чтобы узнать с каким кодом, каким статусом вышел наш дочерний процесс.
pid_t waitpid(pid_t pid, int *status, int options);
https://www.opennet.ru/man.shtml?topic=waitpid&category=2&russian=0
3. execve - наша самая основная функция
https://www.opennet.ru/docs/RUS/linux_parallel/node8.html - execve
int execve(char *name, char *arv[], char *envp[]);
name - это имя нашего исполняемого файла
argc - это тот двухмерный массив, который придет в main исполняемого файла, это те аргументы, которые вы будете передавать командам
envp - в мейн можно передать еще третий параметр - это переменные окружения.
Мы можем из нашего мейника minishell вызвать условный ls.
execve запускает другие бинарники, которые у нас имеются на компьютере.
kill - https://www.opennet.ru/man.shtml?topic=kill&category=2 - посылает сигнал процессу.
fork, pipe, execve, dup/dup2 - эти 4 обязательно нужны
4. dup - создать дубликат файлового дескриптора. https://www.opennet.ru/man.shtml?topic=dup2&category=2&russian=0
мы посылаем туда fd терминала, dup вернет дубликат, чаще всего 3, цифру нового фдшника.
Логика программы:
Этап парсинга.
Реализация build-in команд - echo, cd, pwd, export, unset, env, exit. Мы их должны реализовать сами.
Сигналы - ctrl-C, ctrl-D, ctrl-/
Запуск внешних программ
Логика редиректов\пайпов
Обработка ошибок
echo -n - флаг убирает перенос строки.
Обработка ошибок.
сommand not found.
No such file or directory.
Permission denied.
syntax error near unexpected token newline
поделить задачи с тиммейтом
Точки входа и выхода ваших кусов кода
В каком виде вы передаете данные
Определить структуры данных, с оторыми вы будете работать
Этапы парсинга.
1. Переменные окружения.
2. Одинарные и двойные кавычки. Их отличия.
3. Экранирование
4. Пайпы\редиректы
5. semicolon
Переменные окружения лучше перемаллочить в свой двумерный массив.
echo $path выведет содержимое переменной path
echo $path$qwe выведет содержимое двух переменных (если они обе существуют) NB! $path$qwe - это один аргумент. Два аргумента появляются когда они разделены пробелом. "qwe"'qwe' - это один аргумент.
echo $pathqwe ничего не выведет, если такой переменной не существует
Баш парсит ключ до спец символов. ' " \ $ пробел Кавычки входят в спецсимволы.
'' - сильные кавычки
В каком виде записали информацию в одинарных кавычках, в таком жже виде она ппадет дальше.
Там ничего нигде не парсится. Не работает экранирование, $ и другие спецсимволы.
"" - слабые кавычки
В двойных кавычках подставляется переменные. Обрабатываются пробелы как символы, в отличие от аргументов без кавычек. (пробелы в кавычках считаются как символы.)
Важно! Как только bash увиде двойные кавычки, он обрабатывает всю информацию как в двойных кавычках.
" '  $path '  "  - в этом случае path подставится
Экранирование.
Отличается экранирование без кавычек, в двойных кавычках и в одинарных кавычках.
\t "\t" '\t'
\t - без кавычек, экранируется абсолютно всего
'\t'- в одинарных кавычках, не экранируется ничего
В двойных кавычках экранируется двойной слэш \ " $  - Например, echo "\\" выведет \.  Экранируется двойная кавычка "\" - в данном примере вторая кавычка будет экранирована и баш попросит ввести вторую парную.
\t в двойных кавычках экранироватся не будет
semicolon ;
Если мы хотим вызвать две разных команды, но в одной командной строке, то мы разделяем их точкой с запятой ;  Например pwd ; pwd выполнится , а pwd pwd выдаст ошибку, что слишком много аргуметов. ; похожа на && -, например, pwd && pwd
Если без точки с запятой баш подумает, что я передал два аргумента и попытается обработать их вместе.
ВАЖНО! Если встретили точку с запятой вне кавычек, то нужно сразу отработать ээту программу.
Плоха практика использовать сплит или измененный сплит, лучше идти посимвольно.
Команды с путем и без.
ls и ./ls будут работать по-разному. В первом случае это команды ls, а во втором случае какой-то файл ls в текущей директории.
 важный тест unset PATH далее ls в текуще директории ничего не выведет , а /bin/ls сработает.
